	% options:
% thesis=B bachelor's thesis
% thesis=M master's thesis
% czech thesis in Czech language
% english thesis in English language
% hidelinks remove colour boxes around hyperlinks

\documentclass[thesis=M,english]{FITthesis}[2012/10/20]

% \usepackage[utf8]{inputenc} % LaTeX source encoded as UTF-8
% \usepackage[latin2]{inputenc} % LaTeX source encoded as ISO-8859-2
% \usepackage[cp1250]{inputenc} % LaTeX source encoded as Windows-1250

\usepackage{graphicx} %graphics files inclusion
% \usepackage{subfig} %subfigures
\usepackage{amsmath, kbordermatrix, amssymb} %advanced maths
\usepackage{amsthm} %theorems and lemmas
% \usepackage{amssymb} %additional math symbols
\usepackage[linesnumbered,lined,boxed]{algorithm2e}
\usepackage{enumitem}
\usepackage{dirtree} %directory tree visualisation
\PassOptionsToPackage{hyphens}{url}\usepackage{hyperref}
% % list of acronyms
% \usepackage[acronym,nonumberlist,toc,numberedsection=autolabel]{glossaries}
% \iflanguage{czech}{\renewcommand*{\acronymname}{Seznam pou{\v z}it{\' y}ch zkratek}}{}
% \makeglossaries

% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 
% EDIT THIS
% % % % % % % % % % % % % % % % % % % % % % % % % % % % % % 

\department{Department of Theoretical Computer Science}
\title{Meeting Scheduler}
\authorGN{Luk{\' a}{\v s}} %author's given name/names
\authorFN{Koc} %author's surname
\author{Luk{\' a}{\v s} Koc} %author's name without academic degrees
\authorWithDegrees{Bc. Luk{\' a}{\v s} Koc} %author's name with academic degrees
\supervisor{Ing. Jan Baier}
\acknowledgements{THANKS (remove entirely in case you do not with to thank anyone)}

\abstractEN{Summarize the contents and contribution of your work in a few sentences in English language.}

\abstractCS{V n{\v e}kolika v{\v e}t{\' a}ch shr{\v n}te obsah a p{\v r}{\' i}nos t{\' e}to pr{\' a}ce v {\v c}esk{\' e}m jazyce.}

\placeForDeclarationOfAuthenticity{Prague}
\keywordsCS{Replace with comma-separated list of keywords in Czech.}
\keywordsEN{Replace with comma-separated list of keywords in English.}
\declarationOfAuthenticityOption{1} %select as appropriate, according to the desired license (integer 1-6)

% \website{http://site.example/thesis} %optional thesis URL

%%%%%% Theorem package def
\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}
\renewcommand{\qedsymbol}{$\heartsuit$}
%%%%%% Theorem package def

\begin{document}

% \newacronym{CVUT}{{\v C}VUT}{{\v C}esk{\' e} vysok{\' e} u{\v c}en{\' i} technick{\' e} v Praze}
% \newacronym{FIT}{FIT}{Fakulta informa{\v c}n{\' i}ch technologi{\' i}}

\setsecnumdepth{part}
\chapter{Introduction}
%TODO


\setsecnumdepth{all}
\chapter{State-of-the-art}

\section{Geographic information system}
Geographic information systems (GIS) are solving problems which are based on geospatial information. To achieve the goal special tools are being used such as remote sensing tools, geography tools and visualization software. Remote sensing tools gain information on specific object or area from a distance. Geography tools help to observe and research the environmental changes of Earth and its resources, evolution of society or species. Visualization software then displays gathered data as 2D or 3D images \cite{Chen10}.

With a drastic change of modern technologies and enormous amount of data a new science was born---geographic information science---which is focusing on geographic concepts, applications and systems. The new science opens door to new problems and issues at global scale, not easily imaginable a few years ago. 

The thesis is using knowledge gathered through the course of time in geographic information science to map graph theory problems on a real life data. The developed application belongs to the software category GIS software. 

\section{A need for data}
\label{S1: Good data}
As stated in the bachelor thesis \cite{Koc14}, proficient functioning of the application requires fitting data source. The application needs to work with reliable and (preferably) daily updated data. The area of coverage should be big enough to make the application useful, so that many users would find it convenient. The data format should be unified in order to make manipulation and management effective. Choosing correct data format also enables the application to combine different data sources.

To sum up the data are required to follow certain criteria:
\begin{itemize}
	\item up-to-date
	\item verified
	\item human and computer readable
	\item easy-to-use and unified format
	\item freely available
	\item maintained
\end{itemize}



\section{Possible data-sources}

While searching for data the focus was centred on sources providing free data of Europe available for general public. Further subsections describe sources which matched the criteria mentioned in section \ref{S1: Good data}.

%\subsection{Global map data}
%Global map data provided and managed by International Steering Commitee for Global Mapping.
%TODO
 
\subsection{EuroGeographics}
EuroGeographics is the membership association consisted of 60 organizations and 46 countries. It was created in year 2002, when the Comit{\' e}e Europ{\' e}en des Responsables de la Cartographie Officielle (CERCO) and the Multi-purpose European Ground Related Information Network (MEGRIN) merged together. Its goal is to gather and collect spatial and infrastructural data of Europe \cite{Euro16}. 

EuroGeographics association provides following products: EuroBoundaryMap, EuroGlobalMap, EuroRegionalMap and EuroDEM.
Boundary map mostly covers borders and administrative informations, DEM map is commonly used for environmental change research or hydrologic modelling.
EuroGlobalMap and EuroRegionalMap consists of many datasets: the administrative boundaries, the water network, the transport network etc. 
In order to download the data it is required to fill up the registration form.

EuroGeographics provides data in following formats

\begin{itemize}
\item Geodatabase
\item Shapefile
\end{itemize}


\subsection{OpenStreetMaps}
OpenStreetMaps (OSM) is a project officially supported by the OSM Foundation.
OSM was created to build and provide open\footnote{Open data means for any purpose as long as the OSM and it's contributors are credited.} geographical data available to everyone.  

The OMS project was inspired by Wikipedia and is working exactly the same: Users are the ones contributing with their maps, gps measurements, aerial photographs etc. Since OSM creation in 2004 its community has significantly increased and the data are being updated daily.
OSM provides data in their .osm format, which follows XML rules.

In course of time a lot of project was created which works with OSM maps.
Thanks to the team Mapzen and their Metro Extract project it is possible to download any major city data in additional two GIS data formats:
\begin{itemize}
\item Geojson
\item Shapefile
\end{itemize}

\subsection{EEA}
The European environmental agency (EEA) is agency of European Union providing information about environment for general public. According to their official site \cite{EEA16} it currently consists of 33 member countries.

EEA offers plenty different datasets, maps and graph about nationally designated areas, ecosystem types of Europe, water state and quality, national communications etc. 

Depending on the type, these data are provided in following formats:
\begin{itemize}
\item Excell table
\item CSV
\item Shapefile
\end{itemize} 

Most of the datasets are displayed in interactive maps available on the \href{http://www.eea.europa.eu/data-and-maps}{EEA website}.


\subsection{European Observation Network for Territorial Development and Cohesion}
The European Observation Network for Territorial Development and Cohesion (ESPON) 2013 Programme is mainly financed from European Regional Development Fund (ERDF) and the main goal is:

\textit{"Support policy development in relation to the aim of territorial cohesion and a harmonious development of the European territory \ldots "} \cite{ESPON13}

Data are available as soon as user registers and accepts the Term \& Conditions. EPSON 2013 data are handled according to ISO 19115 scheme in two formats:

\begin{itemize}
\item XML
\item Excel file
\end{itemize}

\section{Data format}
Geographical data exists in many different formats depending on the type and usage of the data. Data representing the elevation of the mountains are better stored in different format than the data representing the location of points of interest. 
Most of the existing formats typically falls into two main categories: vector formats and raster formats. 

% According to Esri's GIS dictionary %TODO cite
Both of them offer two different ways how to represent spatial data. However, the differences between vector and raster data types are equivalent to those in the graphic design world. For better understanding serves the picture \ref{pic:RasterVector} where is graphically explained how these two types differ.
%http://i.stack.imgur.com/Y84dG.png

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{pics/RasterVectorPreview}
\caption{Difference between raster and vector data representation}
\label{pic:RasterVector}
\end{figure}

Both representations carry various set of advantages and disadvantages. These will be described in the following subsections.

% http://data.geocomm.com/helpdesk/formats.html
\subsection{Raster representation}
Raster type formats consist of equally sized cells arranged in rows and columns to construct the representation of space. Individual cell contains an attribute value and location coordinates. Together they create images of point, line, area, network or surface.

\paragraph*{Advantages}
\begin{itemize}[noitemsep]
\item Easy and "cheap" to render
\item Represent well both discrete (urban areas, soil types) and continuous data (elevation)
\item Grid nature provides suitability for mathematical modeling or quantitative analysis
\end{itemize}

\paragraph*{Disadvantages}
\begin{itemize}[noitemsep]
\item Large amount of data
\item Scaling required between layers
\item Possible information loss due to generalization (static cell size)
\item Difficult to establish network linkage
\end{itemize}

\subsection{Vector representation}
Vector type formats uses vertices as a basic unit. Vertex consist of x and y coordinates to determine it's position. Using vertices it is possible to create any shape to describe any object. One vertex create point, two can create line etc. Object created by vertices may contain additional attributes describing the feature.

\paragraph*{Advantages}
\begin{itemize}[noitemsep]
\item Topology nature
\item Compact data structure
\item Easy to maintain
\item Bigger analysis capability
\end{itemize}

\paragraph*{Disadvantages}
\begin{itemize}[noitemsep]
\item For effective analysis static topology needs to be created
\item Every update rebuilding topology is necessary
\item Continuous data not effectively represented
\end{itemize}

\section{Summary -- data usage}
Most of the official European sources (EuroGeographics, EPSON) require filling a form for each download of data. This process can be bottom neck for maintenance part of the application while updating the data would take big amount of time and required additional functionality. 

%Next very significant part of the choice is the data format. As was said in subsection HERE_ADD_SECTION well 

\chapter{Analysis and design}

\section{Data storage}
%TODO
Since the data source and format question is resolved, next step is to decide the representation of graph in the memory. During the history of graph theory there are three main representations to choose from. In following subsections we will take closer look at all three options.

\subsection{Adjacency list}
Adjacency list stores graph as a list of vertices. Each vertex then contains an information about it's adjacent vertices in form of linked list. Adjacency list is easy to implement and use. All vertices in a graph are mapped onto the array of pointers referencing to a first node of a linked list. In case a vertex does not have the adjacent vertices its pointer is set to null. An example of adjacency list for a simple graph can be found in Figure \ref{pic:AdjacencyList}. 

\begin{figure}[h]
\centering
\includegraphics[width=0.8\textwidth]{pics/GraphRep}
\caption{Representation of graph using adjacency list}
\label{pic:AdjacencyList}
\end{figure}


\subsection{Adjacency matrix}
\label{subsec:AdjMatrix}
Adjacency matrix is defined as matrix of a size $|V(G)| \times |V(G)|$, where $V(G)$ is a set of all vertices in graph $ G $. Values within the matrix depends on the type of the graph. Generally for unweighted graph we define adjacency matrix as a $\textbf{A}(G)=[a_{ij}] $, where $a_{ij}$ is the number of edges joining $v_i$ and $v_j$. If the graph is weighted, the values are from interval $\langle 0, \infty ) $, where $0$ means two vertices are not adjacent and any non-zero value means they are adjacent with an edge cost of that value\cite{Bondy76}. Although between every two vertices must exist 1 edge at most.
For the graph G in the Figure \ref{pic:AdjacencyList} adjacency matrix $\textbf{A}$ looks exactly like:
\[
\textbf{A}(G) =
\kbordermatrix{
 & v_{0} & v_{1} & v_{2} & v_{3} & v_{4} \\
v_{0} & 0 & 1 & 0 & 0 & 1 \\
v_{1} & 0 & 0 & 1 & 1 & 0 \\
v_{2} & 0 & 0 & 0 & 1 & 0 \\
v_{3} & 0 & 0 & 0 & 0 & 0 \\
v_{4} & 0 & 0 & 0 & 1 & 0 	
}
\]
Rows and columns represent vertices of a graph. In my case first row and first column represents vertex $0$, second row and column vertex $1$ etc. Value in third row and fourth column means that vertex 2 is adjacent with vertex 3. % As an interesting observation 
It is noticeable that because my example graph is directed, adjacency matrix is not symmetric. %TODO possible extent of directed/undirected graphs

\subsection{Incidence matrix}
Incidence matrix is very similar to adjacency matrix, but instead of showing relations between vertices themselves it represents relation between vertices and edges. Which means size of incidence matrix is $|V(G)| \times |E(G)|$, where $V(G)$ is a set of all vertices and $E(G)$ is set of all edges in graph $ G $. Incidence matrix of graph G is then $\textbf{M}(G) = [m_{ij}]$, where $m_{ij}$ is the number of times (0, 1 or 2 in case of loop) that vertex $v_i$ and edge $e_j$ are incident\cite{Bondy76}.

Interesting case is incidence matrix for directed graph. In that case the sign of the value within matrix $\textbf{M}$ describes the orientation of the edge. Given the edge $e = (x, y)$ then in the row of vertex $x$ and corresponding column for edge $e$ is value is positive and in the row of vertex $y$ and corresponding column for edge $e$ is negative.
For the graph G in the Figure \ref{pic:AdjacencyList} incidence matrix $\textbf{M}$ looks exactly like:

\[
\textbf{M}(G) =
\kbordermatrix{
 & e_{0} & e_{1} & e_{2} & e_{3} & e_{4} & e_5 \\
v_{0} & 1  & 0  & 1  & 0  & 0  & 0 \\
v_{1} & -1 & 1  & 0  & 1  & 0  & 0 \\
v_{2} & 0  & -1 & 0  & 0  & 1  & 0 \\
v_{3} & 0  & 0  & 0  & -1  & -1  & -1 \\
v_{4} & 0  & 0  & -1 & 0  & 0  & 1
}
\]



\subsection{Sparse matrix}
In mathematics matrices can be divided into two groups: sparse matrices and dense matrices. The definition might sound somehow vague, but sparse matrix is matrix containing huge amount of zero elements. Dense matrix is the exact opposite: containing very few zero elements. In previous subsections it is noticeable that each of the matrices (adjacency and incidence) consist of a lot of zero elements and only few are actually useful values.

The amount of non-zero elements in the adjacency or incidence matrix depends purely on degree of vertices in the graph. In both types of matrices, each row serve as a vertex and within non-zero values represent edges incident to the vertex. Depending on if the graph is directed or undirected the amount of non-zero elements in adjacency matrix will differ. Incidence matrix does not change its number, because it differs only in sign of the value. 

For undirected graphs the number of non-zero elements equals to $$ \sum_{v \in V} \textrm{deg(v)} = 2|E| $$ where $E$ set of all edges and $V$ set of all vertices in graph. Same applies to the directed graph for incidence matrix. For directed graph and adjacency matrix we can observe that the number of non-zero elements depends on amount of the outgoing edges $\Rightarrow$ out-degree, which is 
$$ \sum_{v \in V} \textrm{deg\textsuperscript{--}(v)} = |E| $$ where $E$ is set of all edges, $V$ is set of all vertices in graph and $deg\textsuperscript{--}(v)$ function returns number of outgoing edges from the vertex $v$.

The reason why I mentioned sparse matrix in the first place is that there are functions and operations which could be done above the sparse matrices. The main motivation for this section are the storage schemes in which sparse matrix could be stored. Using storage scheme enables all the advantages of the regular matrix representation with significantly less memory usage since only the non-zero elements are being stored.

According to \cite{Saad03} there are X storage schemes. 

Coordinate format belongs to the simplest storage schemes of sparse matrices. The data structure consists of three arrays: an array containing all the (real or complex) values of the non-zero elements of the original matrix in any order, an integer array containing their row indices and a second integer array containing their column indices. All three arrays are of length $N$, which is the number of non-zero elements.

Let us take a look at adjacency $\textbf{A}$ matrix from section \ref{subsec:AdjMatrix}. Clearly this matrix contains less non-zero elements, therefore it is an example of sparse matrix. Using coordinate format matrix $\textbf{A}$ looks the following way:

$$
\begin{array}{c}

AA:
\begin{array}{|c|c|c|c|c|c|}
 \hline
 1 & 1 & 1 & 1 & 1 & 1 \\
 \hline
\end{array}
\\ \\
IR:
\begin{array}{|c|c|c|c|c|c|}
 \hline
 0 & 1 & 2 & 0 & 1 & 4 \\
 \hline
\end{array}
\\ \\
IC:
\begin{array}{|c|c|c|c|c|c|}
 \hline
 4 & 2 & 3 & 1 & 3 & 3 \\
 \hline
\end{array}
\end{array}
$$

Array $AA$ stores values of non-zero elements, array $IR$ stores the row index of the corresponding element and array $IC$ stores the column index of the corresponding element. The memory needed for storing matrix is now only $3N$ instead of the original $N^2$.

If the elements inside array $AA$ are listed by row, the array $IR$ could be transformed to store only indices of the beginning of each row instead. The size of newly defined array $IR$ is then $n+1$, where $n$ is number of rows in original matrix. On the last position ($+1$) is being written the number on non-zero elements within the original matrix. It also may be represented as address, where fictional $n+1$ row begins. 

Array $\textbf{A}$ then would be by this scheme described in the following way:

$$
\begin{array}{c}
AA:
\begin{array}{|c|c|c|c|c|c|}
 \hline
 1 & 1 & 1 & 1 & 1 & 1 \\
 \hline
\end{array}
\\ \\
IR:
\begin{array}{|c|c|c|c|c|c|}
 \hline
 0 & 2 & 4 & 5 & 5 & 6 \\
 \hline
\end{array}
\\ \\
IC:
\begin{array}{|c|c|c|c|c|c|}
 \hline
 1 & 4 & 2 & 3 & 3 & 3 \\
 \hline
\end{array}
\end{array}
$$



The transformation of the $IR$ array and listing elements inside $AA$ by row is called Compressed Sparse Row (CSR) format. In scientific computing CSR format is most commonly used for vector-matrix multiplication while having low memory usage. On the other hand coordinate format excels with it\'s simplicity and flexibility.
Compressed Sparse Row format through the years develops in many number of variations. 
While storing columns instead of rows, we create a new scheme known as Compressed Sparse Column (CSC) format.

The last scheme I would like to point out is the Ellpack-Itpack format which is very popular on vector machines. The Ellpack-Itpack format stores matrix in two 2-dimensional arrays of the same size $n \times N_{mpr}$, where $n$ is the number of rows of the original matrix and $N_{mpr}$ represents maximum of non-zero elements per row. The first array contains non-zero elements of original matrix. If the number of non-zero elements is less then the $N_{mpr}$, the rest of the row is filled with zeroes. The second array stores the information about the column in which specific non-zero element is located. For each zero in the first array can be added any number.

For the given matrix $\textbf{EIF}$:

$$
\begin{array}{c}
\textbf{EIF} = 
\begin{pmatrix}
4 & 0 & 0 & 1 & 0 \\
0 & 0 & 7 & 0 & 9 \\
0 & 2 & 0 & 0 & 0 \\
6 & 0 & 0 & 1 & 0 \\
0 & 0 & 0 & 4 & 3\\
\end{pmatrix}
\end{array}
$$

the Ellpack-Itpack format looks following:
 
$$
\begin{array}{lr}
\textbf{AA} = 
\begin{pmatrix}
4 & 1 \\
7 & 9 \\
2 & 0 \\
6 & 1 \\
4 & 3 \\
\end{pmatrix}
\quad \quad
\textbf{IC} = 
\begin{pmatrix}
0 & 3  \\
2 & 4 \\
1 & 0 \\
0 & 3\\
3 & 4 \\
\end{pmatrix}
\end{array}
$$

\subsection{List and matrix comparison}
%Both matrices and list stores equivalent information about the graph. From incidence matrix we can read which two edges share the same vertex (they are incident) and from adjacency matrix which two vertex are connected with an edge. Adjacency list stores for each vertex node edge information in form of linked list which brings two main benefits. 

Adjacency lists in their essence compactly represent existing edges. 
However, this comes at the cost of possibly slow lookup of specific edges.
In case of unordered list, worst case lookup time for a specific edge can become O(n), since each list has length equal to degree of a vertex.
On the other hand, looking up the neighbours of a vertex becomes trivial, and for a sparse or small graph the cost of iterating through the adjacency lists might be negligible.

Adjacency matrices can use more space in order to provide constant lookup time. Since every possible entry exists you can check for the existence of an edge in constant time using indexes. However, lookup time for a neighbour becomes O(n) since it is needed to check all possible neighbours.

Most real-world problems produce sparse and/or large graphs, for which adjacency list representations suit better.

\section{Definitions and problem description}

\subsection{Directed graph}
A directed simple \textit{graph} $G$ is a pair $(V, E)$, where $V$ is a finite set of \textit{vertices} and $E \subseteq V \times V$ are the $edges$ of a graph $G$. The number of vertices $|V|$ is denoted by $N$ and the number of edges $|E|$ is denoted by $m$ throughout this thesis, . A $path$ in $G$ is a sequence of vertices $v_1, v_2 \dots ,v_k$ such that $(v_i,v_{i+1}) \in E$ for all $1 \leq i < k$. A path with $v_1 = v_k$ is called a $cycle$. A graph (without multiple edges) can have up to $n^2$ edges. 

% We call a graph \textit{sparse}, if $m \in O(n)$. We assume that we are given a layout $L: V \to R^2$ of the graph in the Euclidean plane. For ease of notation, we will identify a node $v \in V$ with its location $L(v) \in R^2$ in the plane.

\subsection{Shortest path problem}
\label{sec:SPP}
Let $G = (V, E)$ be a directed graph whose edges are weighted by a function $f: E \to \mathbb{R}$. 
The length of a path is the sum of the weights of its edges. In this sense the weights can be reinterpreted as a edge lengths. A cycle whose edges sum to a negative value is \textit{negative cycle}.  

The shortest-path problem consists in finding a path of minimum length from a given source $s \in V$ to a given target $t \in V$.
Note that the problem is only well defined for all pairs, if $G$ does not contain negative cycles.
Since our problem is based on the real world values (distance between two points) negative weights case does not occur it the rest of the thesis.
And even if there are negative weights, but not negative cycles, it is possible, using Johnson's algorithm \cite{Johnson77}, to convert in $O(n_m + n^2 \log n)$ time the original edge weights $f: A \to \mathbb{R}$ to non-negative arc weights $ f': A \to \mathbb{R}^+_0$ that result in the same shortest paths.

For solving shortest path problems exist nowadays many algorithms. Most of them evolved from their predecessors. Each of them solves the problem with different parameters. 
Following list contains the essential shortest path problem algorithms, which provided solid ground in graph theory science:
\begin{itemize}
\item Dijkstra's algorithm
\item Bellman-Ford algorithm
\item Floyd-Warshall algorithm
\item Johnson's algorithm 
\end{itemize}

Dijkstra's algorithm \cite{Dijkstra59} and Bellman-Ford algorithm \cite{Bellman58, FordFulkerson62} solve single-source shortest path (SSSP) problem. SSSP problem can be defined as: Given a directed graph $G = (V,E)$, with non-negative costs on each edge, and a selected source node $v \in V, \forall w \in V$, find the cost of the least cost path from $v$ to $w$. The cost of a path is simply the sum of the costs on the edges traversed by the path. Dijkstra's algorithm is greedy algorithm working with the graph were negative edges are not allowed. Bellman-Ford algorithm is non-greedy version of Dijkstra's algorithm which allows it to work with the graph having negative edges.

Floyd-Warshall algorithm \cite{Warshall62, Floyd56} and Johnson's algorithm \cite{Johnson77} solve the all-pair shortest path (APSP) problem. Floyd-Warshall algorithm iterates all vertices $v$ in order to find better path for every pair going through $v$ in time $O(N^3)$. Johnson's algorithm first converts all the negative edges into positive one and then applies Dijsktra's algorithm on every node within the graph. 
For sparse graphs the Johnson's algorithm provides better times than Floyd-Warshall algorithm \cite{Cormen01}.

\section{Dijkstra algorithm}
\label{sec:dijsktra}
Algorithm was conceived by Edsger Wybe Dijkstra in 1956 and was officially published in 1959. Dijkstra's original idea was to find shortest path between two nodes, but through the course of time among computer scientists is Dijkstra algorithm accepted as an algorithm finding path from one single node to all other nodes in graph. 


% about  Mehlhorn, Kurt; Sanders, Peter (2008). Algorithms and Data Structures: The Basic Toolbox (PDF). Springer.
Dijkstra algorithm was constructed to solve real world problem: How to get from one point to the other using shortest path possible. % Frana, Phil (August 2010). "An Interview with Edsger W. Dijkstra". Communications of the ACM. 53 (8): 41–47. doi:10.1145/1787234.1787249
The main criteria used to define shortest path are either time or distance, both quantities having only positive values. If we convert these criteria into graph theory, all the edges of the graph, where graph represents our world and nodes positions in it, need to be also positive.
Because of that, Dijkstra algorithm cannot be used to solve SSSP problem on graphs having negative values (as mentioned in previous chapter). However, the data available are based on real world problems as well therefore Dijkstra algorithm will be perfect foundation as an problem solving algorithm. 

 \subsection{Definition}
There are many variations of Dijkstra algorithm. Here is presented variation, where nodes can be in three states: $fresh, open $ and $closed$. For each node \textbf{n} function \texttt{dist}(\textbf{n}) represents distance from the starting node \textbf{s}. For unreachable nodes value return by this function will be undefined. Next to \texttt{dist} function there is also \texttt{prev}(\textbf{n}), which returns node for the shortest path back to node \textbf{s}.

\begin{algorithm}[H]
\SetKwFunction{Dist}{dist}
\SetKwFunction{Len}{length}
\SetKwFunction{P}{prev}
\SetKwData{Or}{or}
 set the starting node \textbf{s} as \textit{open} and \Dist{\textbf{s}}$ \leftarrow 0$\;
 \For{for each node \textbf{n} different from \textbf{s}}{
  set node \textbf{n} as \textit{fresh}
 }
 \While{$\exists \textbf{u}$ with state open}
 {
  \textbf{u} $\leftarrow$ $open$ node with minimal \Dist{\textbf{u}} \;
  set \textbf{u} state as $closed$	\;
  \ForEach{neighbour \textbf{w} of \textbf{u}}
  {
   \If{\textbf{w} is fresh \Or \Dist{\textbf{w}} $ > $  \Dist{\textbf{u}} $+$ \Len{\textbf{w}, \textbf{u}}}{
	\lIf{\textbf{w} is fresh}{ 
	set \textbf{w} as open}
	\Dist{\textbf{w}} $\leftarrow$ \Dist{\textbf{u}} $+$ \Len{\textbf{w}, \textbf{u}}\;
	\P{\textbf{w}} $\leftarrow \textbf{u}$   
   }
  } 
 }
\caption{Dijkstra algorithm}\label{algo_dijkstra}
\end{algorithm}

On the line number \textbf{6} the choice of the node \textbf{u} means choosing the \textbf{u} with \texttt{dist}(\textbf{u}) $ \leq $ \texttt{dist}(\textbf{w}), where \textbf{w} is every other node having state $open$.

\subsection{Proof of correctness}

In order to prove the algorithm will stop after finite number of step and its correctness, it is needed to define lemma about states in which nodes can be:

%%%%% LEMMA 1
\begin{lemma}
Nodes can only change state either from "\textit{fresh}" to "\textit{open}" or from "\textit{open}" to "\textit{closed}".
\end{lemma}
%%%%% LEMMA 1

%%%%% PRoof1
\begin{proof}
The only time nodes can change state are on line \textbf{7} and \textbf{10} of the Algorithm \ref{algo_dijkstra}.
\end{proof}
%%%%% PRoof1

%%%%% Theorem 2
\begin{theorem}
\label{theorem2}
Dijkstra algorithm will stop computing after at the most \textit{N} steps iterations of while cycle, where N is a number of nodes in graph. 
\end{theorem}
%%%%% Theorem 2

%%%%% Proof 2
\begin{proof}
From the description of the algorithm and previous lemma it is clear the set of closed nodes of cycle will increase with each iteration by one and its size being between 0 and \textit{N}.
\end{proof}
%%%%% Proof 2

%%%%% Theorem 3
\begin{theorem}
Let $A$ be a set of closed nodes. The length already found path from $v_0$ to $v$ is the length of the shortest path $v_0 v_1 \dots v_k v$, where nodes $v_0, v_1, \dots , v_k$ are in set $A$.
\end{theorem}
%%%%% Theorem 3

%%%%% Proof 3
\begin{proof}
The proof is by induction on the number of step executed. The theorem clearly is correct before and after the first step. 

Let $w$ be a node with a state set to closed in last step. Let us consider a node $v$ which is closed.
If $v=w$, then the theorem is trivial. In opposite case case we will show, that there is a shortest path from $v_0$ to $v$ through nodes in set $A$ not containing the node $w$. Set $L$ as a length of the path from $v_0$ to $v$ through the nodes in $A$ without $w$. Because in each step we choose node with the lowest \texttt{dist}(\textbf{u}) and \texttt{dist} of chosen nodes in each step represents nondecreasing sequence (weight of the edges are positive), then the length of the path from $v_0$ to $w$ through nodes in $A$ is at least $D$. Because we have chosen the $D$ we know, there exists a path from $v_0$ to $v$ through nodes in $A$ which is not using node $w$.

Now let us consider a node $v$ which is not closed. Let $v_0 v_1 \dots v_k v$ be the shortest path from $v_0$ to $v$, where $\forall v_0, v_1, \dots v_k v \in A$. 
If $v_k = w$, then we changed the \texttt{dist} to the length of this path in current step. If $v_k \neq w$ then $v_0 v_1 \dots v_k$ is the shortest path from $v_0$ to $v_k$ through nodes in $A$ and so we can assume that no nodes $v_0, v_1, \dots v_k $ is not $w$ (according to last paragraph). Hence the length of the path was already set to the correct value before current step.

Due to the fact, that after last step the set $A$ contains only the nodes, into which exists a path from node $v_0$, we have proven the correctness of Dijkstra algorithm.
\end{proof}
%%%%% Proof 3

\subsection{Time complexity}
Now from the Algorithm \ref{algo_dijkstra} we can compute time general complexity of Dijkstra algorithm. Let us assume we use array in order to store the distances for all the $N$ nodes. As proven in Theorem \ref{theorem2} the whole algorithm will execute at most $N$ steps, in each we are choosing node from the set of \textit{fresh} nodes having size $O(N)$. In each step we also need to check the number of nodes, which are being connected via edges outgoing from the currently checked node. Number of these checks in total is equal to at most $O(E)$, where $E$ is a number of edges in the input graph. To sum up time complexity equals to $O(N^2 + M)$, i.e. $O(N^2)$ since $E$ can be at the most $N^2$.

It is possible to improve this complexity by using heap instead of an array in order to store the distances. In the beginning the heap will contain $N$ elements and in each step this number will be reduced by one: We find and delete smallest one in a time of $O(\log{N})$ and adjusting the distances of the neighbours, which takes $O(E\log{n})$ through all the edges. In total the time complexity of the algorithm is $O((N+M) \log{N})$. As mentioned in Section \ref{sec:dijsktra} for real life problems we expect the graph having a form of a sparse graph, meaning for $M << N^2$ the heap version of the algorithm will provide much more better results.


Dijkstra algorithm is very similar to Bellman-Ford algorithm mentioned in subsection \ref{sec:SPP}. The main difference between these algorithms is repetitive checking of the nodes. Once Dijkstra algorithm closes a node, it will never be checked again. Bellman-Fold algorithm goes through each of the nodes and recalculates the path in case negative edges exists in the graph. Because of this extra step, it is slower then Dijkstra, but can detect whether the graph is valid or not.

\section{User interface design}
The application requires the spacial information as an input. 
User should be able to insert the positions of people in order to find their meeting place and clearly see desired result. For that the user interface (UI) of our application should provide a way how to register and store spacial informations provided by the user. 

Creating a fully satisfiable GUI is not main purpose of this thesis, so I have decided to create simple GUI, where user can insert geographical coordinates of participants and as a result he will receive single pair of coordinates of final destination. 

Fully optimal GUI would allow user to select the position through the displayed map of the dataset currently available. That way the effort of finding coordinates would be eliminated and general user-flow would be significantly improved. The same applies to the result of a application. User would see a marked point on the map to clearly see the meeting point. 

\subsection{Technology used}
The goal of the thesis is to create complex desktop application with basic front-end to provide user proper control over the input data and general overview over the application. In addition, the technology used should be cross-platform. In general, modern high-level programming languages prefer one platform over the other (e.g. C\# Windows, ObjC iOS). 

In direction of keeping my application as a whole simple, the main computation part of the application is written in C\texttt{++} language, which provides great computing performances on any platform while offering OOP principles in order to create more complex applications. In addition, C\texttt{++} based back-end will make deployment on any server operating system effortless. Not to mention there are plenty open source libraries available making a realization of the whole project easily done.  

%% QT 
One of the framework being used is Qt framework. Qt provides cross-platform tools to create basic UI and is classified as FOSS computer software, therefore fitting the purpose of the application being open source.

%% GDAL
For reading the data files and following manipulation GDAL/ORG library was selected. GDAL is design for reading and writing raster GIS formats. 

\chapter{Realisation}

\setsecnumdepth{part}
\chapter{Conclusion}


\bibliographystyle{iso690}
\bibliography{mybibliographyfile}

\setsecnumdepth{all}
\appendix

\chapter{Acronyms}
% \printglossaries
\begin{description}
	\item[APSP] All-pair shortest path
	\item[CERCO] Comit{\' e}e Europ{\' e}en des Responsables de la Cartographie Officielle\item[GUI] Graphical user interface
	\item[DEM] Digital Elevation Model
	\item[ERDF] European Regional Development Fund
	\item[ESPON] European Observation Network for Territorial Development and Cohesion
	\item[FOSS] Free and Open-Source Software
	\item[GDAL] Geospatial Data Abstraction Library
	\item[GIS] Geographic information systems	
	\item[MEGRIN] Multi-purpose European Ground Related Information Network
	\item[OOP] Object Oriented Programming
	\item[OSM] OpenStreetMaps
	\item[SSSP] Single-source shortest path
	\item[XML] Extensible markup language
	
	
\end{description}


\chapter{Contents of enclosed CD}

%change appropriately

\begin{figure}
	\dirtree{%
		.1 readme.txt\DTcomment{the file with CD contents description}.
		.1 exe\DTcomment{the directory with executables}.
		.1 src\DTcomment{the directory of source codes}.
		.2 wbdcm\DTcomment{implementation sources}.
		.2 thesis\DTcomment{the directory of \LaTeX{} source codes of the thesis}.
		.1 text\DTcomment{the thesis text directory}.
		.2 thesis.pdf\DTcomment{the thesis text in PDF format}.
		.2 thesis.ps\DTcomment{the thesis text in PS format}.
	}
\end{figure}

\end{document}
